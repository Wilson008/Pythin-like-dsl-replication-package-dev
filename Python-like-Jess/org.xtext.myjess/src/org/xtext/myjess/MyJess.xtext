// automatically generated by Xtext
// 1. change the reference from Terminals to Xbase grammar
// automatically generated by Xtext
//grammar org.xtext.myjess.MyJess with org.eclipse.xtext.common.Terminals
grammar org.xtext.myjess.MyJess with org.eclipse.xtext.xbase.Xbase

// 2. Import Xbase to refer to EClassifiers from the Xbase model
import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase
import "http://python-like/jess/primitivetypes" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://python-like/jess" as jess

Root returns jess::Root:
	{jess::Root}
	'Root'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (commentsAfter+=String0)* END )?
		('expressions' BEGIN expressions+=Expression (expressions+=Expression)* END )?
	END;

Expression returns jess::Expression:
	Integ | Floa | Str | ValidIdentifier | SlotName | JessVariable | TemplateExpression | GlobalDefinition | FunctionDefinition | AdviceDefinition | UnDefAdvice | FactDefinition | RuleDefinition | ModuleDefinition | QueryDefinition | TemplateDefinition | WhileExp | ForExp | ForeachExp | FuncCall | EngineExp | ExitExp | IfExpression;





Ident returns jess::Ident:
	ValidIdentifier | SlotName | JessVariable;



UseFuncExp returns jess::UseFuncExp:
	WhileExp | ForExp | ForeachExp | FuncCall | EngineExp | ExitExp | IfExpression;



ASlotDef returns jess::ASlotDef:
	ASlotDef_Impl | SlotDef | MultiSlotDef;





String0 returns ecore::EString:
	STRING;

Integ returns jess::Integ:
	'Integ'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (commentsAfter+=String0)* END )?
		'val' val=Integer
	END;

Floa returns jess::Floa:
	'Floa'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'val' val=Double
	END;

Str returns jess::Str:
	'Str'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'val' val=String0
	END;

ValidIdentifier returns jess::ValidIdentifier:

	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'val' val=String0
	END;

SlotName returns jess::SlotName:
	'SlotName'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'val' val=String0
	END;

JessVariable returns jess::JessVariable:
	'JessVariable'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'val' val=String0
	END;

TemplateExpression returns jess::TemplateExpression:
	'TemplateExpression'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'templateName' templateName=ValidIdentifier
		firstSlot=SlotOp
		(slotOp+=SlotOp (  slotOp+=SlotOp)*)?
	END;

GlobalDefinition returns jess::GlobalDefinition:
	{jess::GlobalDefinition}
	'GlobalDefinition'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		(varDef+=VarDefinition (  varDef+=VarDefinition)*)?
	END;

FunctionDefinition returns jess::FunctionDefinition:
	'FunctionDefinition'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'funcName' funcName=ValidIdentifier
		(parameters+=JessVariable (  parameters+=JessVariable)*)?
		('expressions' BEGIN expressions+=Expression (  expressions+=Expression)* END )?
	END;

AdviceDefinition returns jess::AdviceDefinition:
	'AdviceDefinition'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'direction' direction=Advice
		'op' op=Ident
		('advice' BEGIN advice+=Expression (  advice+=Expression)* END )?
	END;

UnDefAdvice returns jess::UnDefAdvice:
	'UnDefAdvice'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'op' op=Expression
	END;

FactDefinition returns jess::FactDefinition:
	'FactDefinition'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'factName' factName=ValidIdentifier
		(documentation=Str)?
		('fact' BEGIN fact+=Expression (  fact+=Expression)* END )?
	END;

RuleDefinition returns jess::RuleDefinition:
	'RuleDefinition'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'ruleName' ruleName=ValidIdentifier
		(documentation=Str)?
		(declare=DeclareRule)?
		('conditions' BEGIN conditions+=Expression (  conditions+=Expression)* END )?
		(functionCall+=UseFuncExp (  functionCall+=UseFuncExp)*)?
	END;

ModuleDefinition returns jess::ModuleDefinition:
	'ModuleDefinition'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'moduleName' moduleName=ValidIdentifier
		(documentation=Str)?
	END;

QueryDefinition returns jess::QueryDefinition:
	'QueryDefinition'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'queryName' queryName=ValidIdentifier
		(documentation=Str)?
		(declare=DeclareVar)?
		('expressions' BEGIN expressions+=Expression (  expressions+=Expression)* END )?
	END;

TemplateDefinition returns jess::TemplateDefinition:
	'TemplateDefinition'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'templateName' templateName=ValidIdentifier
		('inherits' inherits+=ValidIdentifier (  inherits+=ValidIdentifier)*)?
		(documentation=Str)?
		(declareBloc=DeclareBloc)?
		(slotDef+=ASlotDef (  slotDef+=ASlotDef)*)?
	END;

WhileExp returns jess::WhileExp:
	'WhileExp'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'hasDo' hasDo=Boolean
		'boolExp' boolExp=Expression
		('actions' BEGIN actions+=Expression (  actions+=Expression)* END )?
	END;

ForExp returns jess::ForExp:
	'ForExp'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'initializer' initializer=Expression
		'condition' condition=Expression
		'increment' increment=Expression
		('expressions' BEGIN expressions+=Expression (  expressions+=Expression)* END )?
	END;

ForeachExp returns jess::ForeachExp:
	'ForeachExp'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		var=JessVariable
		'list' list=Expression
		('expressions' BEGIN expressions+=Expression (  expressions+=Expression)* END )?
	END;

FuncCall returns jess::FuncCall:
	'FuncCall'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		'funcName' funcName=ValidIdentifier
		('funcParam' BEGIN funcParam+=Expression (  funcParam+=Expression)* END )?
	END;

EngineExp returns jess::EngineExp:
	{jess::EngineExp}
	'EngineExp'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
	END;

ExitExp returns jess::ExitExp:
	{jess::ExitExp}
	'ExitExp'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
	END;

IfExpression returns jess::IfExpression:
	'IfExpression'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		ifthen=ConditionAction
		(elifthen+=ElifConditionAction (  elifthen+=ElifConditionAction)*)?
		('else' BEGIN else+=Expression (  else+=Expression)* END )?
	END;

Integer returns ecore::EInt:
	INT;

Double returns ecore::EDouble:
	INT '.' INT;

SlotOp returns jess::SlotOp:
	'SlotOp'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		slotIdent=SlotName
		'operator' operator=ValidIdentifier
		'exp' exp=Expression
	END;

VarDefinition returns jess::VarDefinition:
	'VarDefinition'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		jessVar=JessVariable
		'eq' eq=ValidIdentifier
		expression=Expression
	END;

enum Advice returns jess::Advice:
				before = 'before' | after = 'after';

DeclareRule returns jess::DeclareRule:
	{jess::DeclareRule}
	'DeclareRule'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (  commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (  commentsAfter+=String0)* END )?
		('salience' salience=Expression)?
		('nodeIndexHash' nodeIndexHash=Expression)?
		('autoFocus' autoFocus=ValidIdentifier)?
		(noLoop=ValidIdentifier)?
	END;

DeclareVar returns jess::DeclareVar:
	'DeclareVar'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (commentsAfter+=String0)* END )?
		(var+=JessVariable (var+=JessVariable)*)?
		'node' node=Expression
		'max' max=Expression
	END;

DeclareBloc returns jess::DeclareBloc:
	{jess::DeclareBloc}
	'DeclareBloc'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (commentsAfter+=String0)* END )?
		('slotSpecific' slotSpecific=ValidIdentifier)?
		('backchainReaction' backchainReaction=ValidIdentifier)?
		('fromClass' fromClass=ValidIdentifier)?
		('includeVariable' includeVariable=ValidIdentifier)?
		('order' order=ValidIdentifier)?
	END;

ASlotDef_Impl returns jess::ASlotDef:
	'ASlotDef'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (commentsAfter+=String0)* END )?
		'slotName' slotName=SlotName
		(optionals+=SlotOptions (optionals+=SlotOptions)*)?
	END;

SlotOptions returns jess::SlotOptions:
	'SlotOptions'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (commentsAfter+=String0)* END )?
		'type' type=ValidIdentifier
		'def' def=Expression
		'defaultDyn' defaultDyn=Expression
		('allowedValues' BEGIN allowedValues+=Expression (allowedValues+=Expression)* END )?
	END;

SlotDef returns jess::SlotDef:
	'SlotDef'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (commentsAfter+=String0)* END )?
		'slotName' slotName=SlotName
		(optionals+=SlotOptions (optionals+=SlotOptions)*)?
	END;

MultiSlotDef returns jess::MultiSlotDef:
	'MultiSlotDef'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (commentsAfter+=String0)* END )?
		'slotName' slotName=SlotName
		(optionals+=SlotOptions (optionals+=SlotOptions)*)?
	END;

Boolean returns ecore::EBoolean:
	'true' | 'false';

ConditionAction returns jess::ConditionAction:
	'ConditionAction'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (commentsAfter+=String0)* END )?
		'condition' condition=Expression
		('actions' BEGIN actions+=Expression (actions+=Expression)* END )?
	END;

ElifConditionAction returns jess::ElifConditionAction:
	'ElifConditionAction'
	BEGIN
		('location' location=String0)?
		('commentsBefore' BEGIN commentsBefore+=String0 (commentsBefore+=String0)* END )?
		('commentsAfter' BEGIN commentsAfter+=String0 (commentsAfter+=String0)* END )?
		condAct=ConditionAction
	END;

// 3. include whitespace-aware blocks in your language is to use synthetic tokens in the grammar 
//    by writing terminals of the form 'synthetic:<terminal name>'
terminal BEGIN: 'synthetic:BEGIN';
terminal END: 'synthetic:END';

// 4. inherits expressions from Xbase and redefines the syntax of block expressions
@Override
XBlockExpression returns xbase::XExpression:
    {xbase::XBlockExpression}
    BEGIN
        (expressions+=XExpressionOrVarDeclaration ';'?)*
    END;
